# KoKo

KoKo lets you create `Property` objects as fields of your models.

Unlike built-in C# [properties](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties), KoKo `Property` objects automatically fire change events. They can be composed from multiple other Properties without the dependencies being aware of the dependents, and without manually writing any event handling code.

## Installation
**[KoKo on NuGet Gallery](https://www.nuget.org/packages/KoKo/)**

1. Right-click on your C# project and go to Manage NuGet Packages
1. Under Browse, search for `KoKo`
1. Click the down arrow button for `KoKo`

## Usage
1. Create a `class` to act as your business or view model
1. Import the `KoKo.Property` namespace
1. Add some `Property` fields
1. Get and set their `Value`

## Example
This is a just a silly, simple example. [Don't actually represent people's names this way.](https://www.w3.org/International/questions/qa-personal-names)

```cs
using KoKo.Property;

namespace Project1
{
    class Person
    {
        readonly StoredProperty<string> firstName;
        readonly StoredProperty<string> lastName;
        readonly Property<string> fullName;

        Person(string firstName, string lastName)
        {
            this.firstName = new StoredProperty<string>(firstName);
            this.lastName = new StoredProperty<string>(lastName);

            fullName = new DerivedProperty<string>(new[] { this.firstName, this.lastName },
                () => $"{this.firstName.Value} {this.lastName.Value}");
        }

        void ChangeFirstName(string newFirstName)
        {
            firstName.Value = newFirstName;
        }
    }
}
```

Now you can get a `person` object's autogenerated full name,

```cs
var person = new Person("Alice", "Smith");
Console.WriteLine(person.fullName.Value); // Alice Smith
```

and if you change a dependency value, the full name will be automatically updated.

```cs
person.ChangeFirstName("Bob");
Console.WriteLine(person.fullName.Value); // Bob Smith
```

You can also use Properties with databinding:

```cs
private void Form1_Load(object sender, System.EventArgs e)
{
    personNameLabel.DataBindings.Add("Text", model.fullName, "Value");
}
```

## Properties

### `StoredProperty`

- Stores a single value in memory
- Value can be get or set imperatively
- Similar to a C# property, except you don't have to implement `INotifyPropertyChanged` yourself

```cs
var a = new StoredProperty<string>("world");
Console.WriteLine($"Hello {a.Value}"); // Hello world
a.Value = "world!";
Console.WriteLine($"Hello {a.Value}"); // Hello world!
```

### `DerivedProperty`

- Automatically calculates its value from other _dependency_ properties
- Cannot set the value directly, but you can get the value just like a `StoredProperty`

```cs
var b = new StoredProperty<int>(8);
var absoluteValueB = new DerivedProperty<int>(new[] { b }, () => System.Math.Abs(b.Value));
Console.WriteLine($"The absolute value of {b.Value} is {absoluteValueB.Value}."); // The absolute value of 8 is 8.
b.Value = -9;
Console.WriteLine($"The absolute value of {b.Value} is {absoluteValueB.Value}."); // The absolute value of -9 is 9.
```

### `PassthroughProperty`

- Like a `DerivedProperty`, except it depends on a single property and does not transform the value at all

```cs
var a = new StoredProperty<double>(3.0);
var b = new PassthroughProperty<double>(a);
Console.WriteLine($"{b.Value} liters"); // 3 liters
a.Value = 5.0;
Console.WriteLine($"{b.Value} liters"); // 5 liters
```
